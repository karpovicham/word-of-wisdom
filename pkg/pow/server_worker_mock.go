package pow

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ServerWorkerMock implements ServerWorker
type ServerWorkerMock struct {
	t minimock.Tester

	funcGenerateNew          func(ctx context.Context, clientName string) (d1 Data, err error)
	inspectFuncGenerateNew   func(ctx context.Context, clientName string)
	afterGenerateNewCounter  uint64
	beforeGenerateNewCounter uint64
	GenerateNewMock          mServerWorkerMockGenerateNew

	funcValidateWorkDone          func(ctx context.Context, clientName string, data Data) (err error)
	inspectFuncValidateWorkDone   func(ctx context.Context, clientName string, data Data)
	afterValidateWorkDoneCounter  uint64
	beforeValidateWorkDoneCounter uint64
	ValidateWorkDoneMock          mServerWorkerMockValidateWorkDone
}

// NewServerWorkerMock returns a mock for ServerWorker
func NewServerWorkerMock(t minimock.Tester) *ServerWorkerMock {
	m := &ServerWorkerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GenerateNewMock = mServerWorkerMockGenerateNew{mock: m}
	m.GenerateNewMock.callArgs = []*ServerWorkerMockGenerateNewParams{}

	m.ValidateWorkDoneMock = mServerWorkerMockValidateWorkDone{mock: m}
	m.ValidateWorkDoneMock.callArgs = []*ServerWorkerMockValidateWorkDoneParams{}

	return m
}

type mServerWorkerMockGenerateNew struct {
	mock               *ServerWorkerMock
	defaultExpectation *ServerWorkerMockGenerateNewExpectation
	expectations       []*ServerWorkerMockGenerateNewExpectation

	callArgs []*ServerWorkerMockGenerateNewParams
	mutex    sync.RWMutex
}

// ServerWorkerMockGenerateNewExpectation specifies expectation struct of the ServerWorker.GenerateNew
type ServerWorkerMockGenerateNewExpectation struct {
	mock    *ServerWorkerMock
	params  *ServerWorkerMockGenerateNewParams
	results *ServerWorkerMockGenerateNewResults
	Counter uint64
}

// ServerWorkerMockGenerateNewParams contains parameters of the ServerWorker.GenerateNew
type ServerWorkerMockGenerateNewParams struct {
	ctx        context.Context
	clientName string
}

// ServerWorkerMockGenerateNewResults contains results of the ServerWorker.GenerateNew
type ServerWorkerMockGenerateNewResults struct {
	d1  Data
	err error
}

// Expect sets up expected params for ServerWorker.GenerateNew
func (mmGenerateNew *mServerWorkerMockGenerateNew) Expect(ctx context.Context, clientName string) *mServerWorkerMockGenerateNew {
	if mmGenerateNew.mock.funcGenerateNew != nil {
		mmGenerateNew.mock.t.Fatalf("ServerWorkerMock.GenerateNew mock is already set by Set")
	}

	if mmGenerateNew.defaultExpectation == nil {
		mmGenerateNew.defaultExpectation = &ServerWorkerMockGenerateNewExpectation{}
	}

	mmGenerateNew.defaultExpectation.params = &ServerWorkerMockGenerateNewParams{ctx, clientName}
	for _, e := range mmGenerateNew.expectations {
		if minimock.Equal(e.params, mmGenerateNew.defaultExpectation.params) {
			mmGenerateNew.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGenerateNew.defaultExpectation.params)
		}
	}

	return mmGenerateNew
}

// Inspect accepts an inspector function that has same arguments as the ServerWorker.GenerateNew
func (mmGenerateNew *mServerWorkerMockGenerateNew) Inspect(f func(ctx context.Context, clientName string)) *mServerWorkerMockGenerateNew {
	if mmGenerateNew.mock.inspectFuncGenerateNew != nil {
		mmGenerateNew.mock.t.Fatalf("Inspect function is already set for ServerWorkerMock.GenerateNew")
	}

	mmGenerateNew.mock.inspectFuncGenerateNew = f

	return mmGenerateNew
}

// Return sets up results that will be returned by ServerWorker.GenerateNew
func (mmGenerateNew *mServerWorkerMockGenerateNew) Return(d1 Data, err error) *ServerWorkerMock {
	if mmGenerateNew.mock.funcGenerateNew != nil {
		mmGenerateNew.mock.t.Fatalf("ServerWorkerMock.GenerateNew mock is already set by Set")
	}

	if mmGenerateNew.defaultExpectation == nil {
		mmGenerateNew.defaultExpectation = &ServerWorkerMockGenerateNewExpectation{mock: mmGenerateNew.mock}
	}
	mmGenerateNew.defaultExpectation.results = &ServerWorkerMockGenerateNewResults{d1, err}
	return mmGenerateNew.mock
}

// Set uses given function f to mock the ServerWorker.GenerateNew method
func (mmGenerateNew *mServerWorkerMockGenerateNew) Set(f func(ctx context.Context, clientName string) (d1 Data, err error)) *ServerWorkerMock {
	if mmGenerateNew.defaultExpectation != nil {
		mmGenerateNew.mock.t.Fatalf("Default expectation is already set for the ServerWorker.GenerateNew method")
	}

	if len(mmGenerateNew.expectations) > 0 {
		mmGenerateNew.mock.t.Fatalf("Some expectations are already set for the ServerWorker.GenerateNew method")
	}

	mmGenerateNew.mock.funcGenerateNew = f
	return mmGenerateNew.mock
}

// When sets expectation for the ServerWorker.GenerateNew which will trigger the result defined by the following
// Then helper
func (mmGenerateNew *mServerWorkerMockGenerateNew) When(ctx context.Context, clientName string) *ServerWorkerMockGenerateNewExpectation {
	if mmGenerateNew.mock.funcGenerateNew != nil {
		mmGenerateNew.mock.t.Fatalf("ServerWorkerMock.GenerateNew mock is already set by Set")
	}

	expectation := &ServerWorkerMockGenerateNewExpectation{
		mock:   mmGenerateNew.mock,
		params: &ServerWorkerMockGenerateNewParams{ctx, clientName},
	}
	mmGenerateNew.expectations = append(mmGenerateNew.expectations, expectation)
	return expectation
}

// Then sets up ServerWorker.GenerateNew return parameters for the expectation previously defined by the When method
func (e *ServerWorkerMockGenerateNewExpectation) Then(d1 Data, err error) *ServerWorkerMock {
	e.results = &ServerWorkerMockGenerateNewResults{d1, err}
	return e.mock
}

// GenerateNew implements ServerWorker
func (mmGenerateNew *ServerWorkerMock) GenerateNew(ctx context.Context, clientName string) (d1 Data, err error) {
	mm_atomic.AddUint64(&mmGenerateNew.beforeGenerateNewCounter, 1)
	defer mm_atomic.AddUint64(&mmGenerateNew.afterGenerateNewCounter, 1)

	if mmGenerateNew.inspectFuncGenerateNew != nil {
		mmGenerateNew.inspectFuncGenerateNew(ctx, clientName)
	}

	mm_params := &ServerWorkerMockGenerateNewParams{ctx, clientName}

	// Record call args
	mmGenerateNew.GenerateNewMock.mutex.Lock()
	mmGenerateNew.GenerateNewMock.callArgs = append(mmGenerateNew.GenerateNewMock.callArgs, mm_params)
	mmGenerateNew.GenerateNewMock.mutex.Unlock()

	for _, e := range mmGenerateNew.GenerateNewMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.d1, e.results.err
		}
	}

	if mmGenerateNew.GenerateNewMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGenerateNew.GenerateNewMock.defaultExpectation.Counter, 1)
		mm_want := mmGenerateNew.GenerateNewMock.defaultExpectation.params
		mm_got := ServerWorkerMockGenerateNewParams{ctx, clientName}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGenerateNew.t.Errorf("ServerWorkerMock.GenerateNew got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGenerateNew.GenerateNewMock.defaultExpectation.results
		if mm_results == nil {
			mmGenerateNew.t.Fatal("No results are set for the ServerWorkerMock.GenerateNew")
		}
		return (*mm_results).d1, (*mm_results).err
	}
	if mmGenerateNew.funcGenerateNew != nil {
		return mmGenerateNew.funcGenerateNew(ctx, clientName)
	}
	mmGenerateNew.t.Fatalf("Unexpected call to ServerWorkerMock.GenerateNew. %v %v", ctx, clientName)
	return
}

// GenerateNewAfterCounter returns a count of finished ServerWorkerMock.GenerateNew invocations
func (mmGenerateNew *ServerWorkerMock) GenerateNewAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateNew.afterGenerateNewCounter)
}

// GenerateNewBeforeCounter returns a count of ServerWorkerMock.GenerateNew invocations
func (mmGenerateNew *ServerWorkerMock) GenerateNewBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateNew.beforeGenerateNewCounter)
}

// Calls returns a list of arguments used in each call to ServerWorkerMock.GenerateNew.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGenerateNew *mServerWorkerMockGenerateNew) Calls() []*ServerWorkerMockGenerateNewParams {
	mmGenerateNew.mutex.RLock()

	argCopy := make([]*ServerWorkerMockGenerateNewParams, len(mmGenerateNew.callArgs))
	copy(argCopy, mmGenerateNew.callArgs)

	mmGenerateNew.mutex.RUnlock()

	return argCopy
}

// MinimockGenerateNewDone returns true if the count of the GenerateNew invocations corresponds
// the number of defined expectations
func (m *ServerWorkerMock) MinimockGenerateNewDone() bool {
	for _, e := range m.GenerateNewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GenerateNewMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGenerateNewCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGenerateNew != nil && mm_atomic.LoadUint64(&m.afterGenerateNewCounter) < 1 {
		return false
	}
	return true
}

// MinimockGenerateNewInspect logs each unmet expectation
func (m *ServerWorkerMock) MinimockGenerateNewInspect() {
	for _, e := range m.GenerateNewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServerWorkerMock.GenerateNew with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GenerateNewMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGenerateNewCounter) < 1 {
		if m.GenerateNewMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServerWorkerMock.GenerateNew")
		} else {
			m.t.Errorf("Expected call to ServerWorkerMock.GenerateNew with params: %#v", *m.GenerateNewMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGenerateNew != nil && mm_atomic.LoadUint64(&m.afterGenerateNewCounter) < 1 {
		m.t.Error("Expected call to ServerWorkerMock.GenerateNew")
	}
}

type mServerWorkerMockValidateWorkDone struct {
	mock               *ServerWorkerMock
	defaultExpectation *ServerWorkerMockValidateWorkDoneExpectation
	expectations       []*ServerWorkerMockValidateWorkDoneExpectation

	callArgs []*ServerWorkerMockValidateWorkDoneParams
	mutex    sync.RWMutex
}

// ServerWorkerMockValidateWorkDoneExpectation specifies expectation struct of the ServerWorker.ValidateWorkDone
type ServerWorkerMockValidateWorkDoneExpectation struct {
	mock    *ServerWorkerMock
	params  *ServerWorkerMockValidateWorkDoneParams
	results *ServerWorkerMockValidateWorkDoneResults
	Counter uint64
}

// ServerWorkerMockValidateWorkDoneParams contains parameters of the ServerWorker.ValidateWorkDone
type ServerWorkerMockValidateWorkDoneParams struct {
	ctx        context.Context
	clientName string
	data       Data
}

// ServerWorkerMockValidateWorkDoneResults contains results of the ServerWorker.ValidateWorkDone
type ServerWorkerMockValidateWorkDoneResults struct {
	err error
}

// Expect sets up expected params for ServerWorker.ValidateWorkDone
func (mmValidateWorkDone *mServerWorkerMockValidateWorkDone) Expect(ctx context.Context, clientName string, data Data) *mServerWorkerMockValidateWorkDone {
	if mmValidateWorkDone.mock.funcValidateWorkDone != nil {
		mmValidateWorkDone.mock.t.Fatalf("ServerWorkerMock.ValidateWorkDone mock is already set by Set")
	}

	if mmValidateWorkDone.defaultExpectation == nil {
		mmValidateWorkDone.defaultExpectation = &ServerWorkerMockValidateWorkDoneExpectation{}
	}

	mmValidateWorkDone.defaultExpectation.params = &ServerWorkerMockValidateWorkDoneParams{ctx, clientName, data}
	for _, e := range mmValidateWorkDone.expectations {
		if minimock.Equal(e.params, mmValidateWorkDone.defaultExpectation.params) {
			mmValidateWorkDone.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidateWorkDone.defaultExpectation.params)
		}
	}

	return mmValidateWorkDone
}

// Inspect accepts an inspector function that has same arguments as the ServerWorker.ValidateWorkDone
func (mmValidateWorkDone *mServerWorkerMockValidateWorkDone) Inspect(f func(ctx context.Context, clientName string, data Data)) *mServerWorkerMockValidateWorkDone {
	if mmValidateWorkDone.mock.inspectFuncValidateWorkDone != nil {
		mmValidateWorkDone.mock.t.Fatalf("Inspect function is already set for ServerWorkerMock.ValidateWorkDone")
	}

	mmValidateWorkDone.mock.inspectFuncValidateWorkDone = f

	return mmValidateWorkDone
}

// Return sets up results that will be returned by ServerWorker.ValidateWorkDone
func (mmValidateWorkDone *mServerWorkerMockValidateWorkDone) Return(err error) *ServerWorkerMock {
	if mmValidateWorkDone.mock.funcValidateWorkDone != nil {
		mmValidateWorkDone.mock.t.Fatalf("ServerWorkerMock.ValidateWorkDone mock is already set by Set")
	}

	if mmValidateWorkDone.defaultExpectation == nil {
		mmValidateWorkDone.defaultExpectation = &ServerWorkerMockValidateWorkDoneExpectation{mock: mmValidateWorkDone.mock}
	}
	mmValidateWorkDone.defaultExpectation.results = &ServerWorkerMockValidateWorkDoneResults{err}
	return mmValidateWorkDone.mock
}

// Set uses given function f to mock the ServerWorker.ValidateWorkDone method
func (mmValidateWorkDone *mServerWorkerMockValidateWorkDone) Set(f func(ctx context.Context, clientName string, data Data) (err error)) *ServerWorkerMock {
	if mmValidateWorkDone.defaultExpectation != nil {
		mmValidateWorkDone.mock.t.Fatalf("Default expectation is already set for the ServerWorker.ValidateWorkDone method")
	}

	if len(mmValidateWorkDone.expectations) > 0 {
		mmValidateWorkDone.mock.t.Fatalf("Some expectations are already set for the ServerWorker.ValidateWorkDone method")
	}

	mmValidateWorkDone.mock.funcValidateWorkDone = f
	return mmValidateWorkDone.mock
}

// When sets expectation for the ServerWorker.ValidateWorkDone which will trigger the result defined by the following
// Then helper
func (mmValidateWorkDone *mServerWorkerMockValidateWorkDone) When(ctx context.Context, clientName string, data Data) *ServerWorkerMockValidateWorkDoneExpectation {
	if mmValidateWorkDone.mock.funcValidateWorkDone != nil {
		mmValidateWorkDone.mock.t.Fatalf("ServerWorkerMock.ValidateWorkDone mock is already set by Set")
	}

	expectation := &ServerWorkerMockValidateWorkDoneExpectation{
		mock:   mmValidateWorkDone.mock,
		params: &ServerWorkerMockValidateWorkDoneParams{ctx, clientName, data},
	}
	mmValidateWorkDone.expectations = append(mmValidateWorkDone.expectations, expectation)
	return expectation
}

// Then sets up ServerWorker.ValidateWorkDone return parameters for the expectation previously defined by the When method
func (e *ServerWorkerMockValidateWorkDoneExpectation) Then(err error) *ServerWorkerMock {
	e.results = &ServerWorkerMockValidateWorkDoneResults{err}
	return e.mock
}

// ValidateWorkDone implements ServerWorker
func (mmValidateWorkDone *ServerWorkerMock) ValidateWorkDone(ctx context.Context, clientName string, data Data) (err error) {
	mm_atomic.AddUint64(&mmValidateWorkDone.beforeValidateWorkDoneCounter, 1)
	defer mm_atomic.AddUint64(&mmValidateWorkDone.afterValidateWorkDoneCounter, 1)

	if mmValidateWorkDone.inspectFuncValidateWorkDone != nil {
		mmValidateWorkDone.inspectFuncValidateWorkDone(ctx, clientName, data)
	}

	mm_params := &ServerWorkerMockValidateWorkDoneParams{ctx, clientName, data}

	// Record call args
	mmValidateWorkDone.ValidateWorkDoneMock.mutex.Lock()
	mmValidateWorkDone.ValidateWorkDoneMock.callArgs = append(mmValidateWorkDone.ValidateWorkDoneMock.callArgs, mm_params)
	mmValidateWorkDone.ValidateWorkDoneMock.mutex.Unlock()

	for _, e := range mmValidateWorkDone.ValidateWorkDoneMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmValidateWorkDone.ValidateWorkDoneMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidateWorkDone.ValidateWorkDoneMock.defaultExpectation.Counter, 1)
		mm_want := mmValidateWorkDone.ValidateWorkDoneMock.defaultExpectation.params
		mm_got := ServerWorkerMockValidateWorkDoneParams{ctx, clientName, data}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidateWorkDone.t.Errorf("ServerWorkerMock.ValidateWorkDone got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidateWorkDone.ValidateWorkDoneMock.defaultExpectation.results
		if mm_results == nil {
			mmValidateWorkDone.t.Fatal("No results are set for the ServerWorkerMock.ValidateWorkDone")
		}
		return (*mm_results).err
	}
	if mmValidateWorkDone.funcValidateWorkDone != nil {
		return mmValidateWorkDone.funcValidateWorkDone(ctx, clientName, data)
	}
	mmValidateWorkDone.t.Fatalf("Unexpected call to ServerWorkerMock.ValidateWorkDone. %v %v %v", ctx, clientName, data)
	return
}

// ValidateWorkDoneAfterCounter returns a count of finished ServerWorkerMock.ValidateWorkDone invocations
func (mmValidateWorkDone *ServerWorkerMock) ValidateWorkDoneAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateWorkDone.afterValidateWorkDoneCounter)
}

// ValidateWorkDoneBeforeCounter returns a count of ServerWorkerMock.ValidateWorkDone invocations
func (mmValidateWorkDone *ServerWorkerMock) ValidateWorkDoneBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateWorkDone.beforeValidateWorkDoneCounter)
}

// Calls returns a list of arguments used in each call to ServerWorkerMock.ValidateWorkDone.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidateWorkDone *mServerWorkerMockValidateWorkDone) Calls() []*ServerWorkerMockValidateWorkDoneParams {
	mmValidateWorkDone.mutex.RLock()

	argCopy := make([]*ServerWorkerMockValidateWorkDoneParams, len(mmValidateWorkDone.callArgs))
	copy(argCopy, mmValidateWorkDone.callArgs)

	mmValidateWorkDone.mutex.RUnlock()

	return argCopy
}

// MinimockValidateWorkDoneDone returns true if the count of the ValidateWorkDone invocations corresponds
// the number of defined expectations
func (m *ServerWorkerMock) MinimockValidateWorkDoneDone() bool {
	for _, e := range m.ValidateWorkDoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ValidateWorkDoneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterValidateWorkDoneCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidateWorkDone != nil && mm_atomic.LoadUint64(&m.afterValidateWorkDoneCounter) < 1 {
		return false
	}
	return true
}

// MinimockValidateWorkDoneInspect logs each unmet expectation
func (m *ServerWorkerMock) MinimockValidateWorkDoneInspect() {
	for _, e := range m.ValidateWorkDoneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServerWorkerMock.ValidateWorkDone with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ValidateWorkDoneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterValidateWorkDoneCounter) < 1 {
		if m.ValidateWorkDoneMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServerWorkerMock.ValidateWorkDone")
		} else {
			m.t.Errorf("Expected call to ServerWorkerMock.ValidateWorkDone with params: %#v", *m.ValidateWorkDoneMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidateWorkDone != nil && mm_atomic.LoadUint64(&m.afterValidateWorkDoneCounter) < 1 {
		m.t.Error("Expected call to ServerWorkerMock.ValidateWorkDone")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServerWorkerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGenerateNewInspect()

		m.MinimockValidateWorkDoneInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServerWorkerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServerWorkerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGenerateNewDone() &&
		m.MinimockValidateWorkDoneDone()
}
